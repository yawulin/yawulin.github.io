{"meta":{"title":"涯无凌","subtitle":"一枚渣渣前端工程师","description":"涯无凌的个人博客","author":"涯无凌","url":"http://blog.ywulin.com"},"pages":[],"posts":[{"title":"Framework7+Framework7-vue+vue踩坑记（二）","slug":"201707171854","date":"2017-07-19T15:38:44.000Z","updated":"2017-07-19T15:46:33.685Z","comments":true,"path":"201707171854.html","link":"","permalink":"http://blog.ywulin.com/201707171854.html","excerpt":"接上一篇博客“Framework7+Framework7-vue+vue踩坑记（一）”，这里继续framework7+vue+framework7-vue踩坑第二波，同样通过重绘官网demo来运用framework-vue。","text":"接上一篇博客“Framework7+Framework7-vue+vue踩坑记（一）”，这里继续framework7+vue+framework7-vue踩坑第二波，同样通过重绘官网demo来运用framework-vue。 1、f7-message组件图片显示问题f7-message中无法在信息的text属性中使用&lt;img src=&quot;##&quot;&gt;标签，因为vue的模板语法是将html标签直接转换成字符串的，而在这篇博客编写时官方文档也没给出f7-messages中如何插入图片，如要实现以下效果 实现代码如下： 1234567891011121314&lt;f7-messages&gt; &lt;f7-message v-for=\"message in messages\" :text=\"message.text\" :label=\"message.label\" :date=\"message.date\" :name=\"message.name\" :avatar=\"message.avatar\" :type=\"message.type\" :day=\"message.day\" :time=\"message.time\" &gt; &lt;img v-if=\"message.img\" :src=\"message.img\" /&gt; &lt;/f7-message&gt;&lt;/f7-messages&gt; 我们可以看到f7-message的源代码中有一个不具名slot，所以父组件的内容会被插入到该slot所在的Dom位置，这一点是官方文档所没有说明的 123456789101112131415&lt;template&gt; &lt;div :class=\"classesObject\" @click=\"onClick\"&gt; &#123;&#123;day&#125;&#125; &lt;span v-if=\"time\"&gt;&#123;&#123;time&#125;&#125;&lt;/span&gt; &lt;slot name=\"start\"&gt;&lt;/slot&gt; &lt;div class=\"message-name\" v-if=\"name\" @click=\"onNameClick\"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class=\"message-text\" @click=\"onTextClick\"&gt; //不具名slot &lt;slot&gt;&#123;&#123;text&#125;&#125;&lt;/slot&gt; &lt;div class=\"message-date\" v-if=\"date\"&gt;&#123;&#123;date&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"message-avatar\" v-if=\"avatar\" :style=\"&#123;'background-image': 'url(' + avatar + ')'&#125;\" @click=\"onAvatarClick\"&gt;&lt;/div&gt; &lt;div class=\"message-label\" v-if=\"label\"&gt;&#123;&#123;label&#125;&#125;&lt;/div&gt; &lt;slot name=\"end\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 2、f7-messagebar要使用f7-messagebar需要在组件的f7-page加上no-toolbar和toolbar-fixed，使用no-toolbar会隐藏掉所有的.toolbar，而f7-message渲染后根标签是带有.toolbar，因此需要对f7-toolbar的样式进行修改，如下： 123456&lt;style lang=\"less\" scoped&gt;.toolbar.messagebar&#123; transform: none; transition: 0ms;&#125;&lt;/style&gt; 此外，f7-message中的textarea要进行数据双向绑定，直接在组件中使用v-model即可，代码如下： 123456789&lt;f7-messagebar placeholder=\"Message\" send-link=\"Send\" @submit=\"onSubmit\" v-model=\"messageText\"&gt; &lt;f7-link slot=\"before-textarea\" class=\"icon-only\"&gt; &lt;f7-icon icon=\"icon icon-camera\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt;&lt;/f7-messagebar&gt; 3、f7-picker-modal内嵌navbar跟写一个页面的结构一样，在f7-picker-modal内部直接加入即可，在f7-picker-modal中的navbar属于相对定位，所以不需要在f7-picker-modal中加上navbar-through 4、$router无跳转到首页的方法$router默认是使用ajax加载页面的，.vue页面中的html结构并不完整，framework7-vue是通过解析.vue中的内容，然后将内容插入到对应的位置，并实现过渡动画。因此，如果在router.js中加上app.vue的路由，那就是将app.vue的结构再嵌进f7-pages中，是无法正常显示的。目前我没有找到官方的方法来直接跳转到首页，因此是将app.vue中f7-pages里面的部分提取出来作为一个组件（结构跟其他.vue页面的结构一样，所以可以加上路由进行跳转），比如叫做mainPage.vue在app.vue中引入该组件，放到f7-pages里面，之后要跳转到首页就跟跳转到其他页面一样，将链接指向mainPage.vue的路由即可(如有更好的方式，麻烦告知一下) 5、tabbar的实现在framework7官网中，根据f7+vue的官方文档的Navigation / Router页面，实现tabbar功能，如下： 123456789101112131415161718192021222324252627282930&lt;f7-toolbar tabbar&gt; &lt;f7-link route-tab-link=\"#tab1\" icon-f7=\"help\" href=\"/navbarsAndToolbars/tabbar/\" &gt;&lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab2\" icon-f7=\"drawers\" icon-badge=\"9\" badge-color=\"red\" href=\"/navbarsAndToolbars/tabbar/tab2/\" &gt;&lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab3\" icon-f7=\"cloud\" href=\"/navbarsAndToolbars/tabbar/tab3/\" &gt;&lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab4\" icon-f7=\"camera\" href=\"/navbarsAndToolbars/tabbar/tab4/\" &gt;&lt;/f7-link&gt;&lt;/f7-toolbar&gt;&lt;f7-tabs&gt; &lt;f7-tab route-tab-id=\"tab1\"&gt;&lt;/f7-tab&gt; &lt;f7-tab route-tab-id=\"tab2\"&gt;&lt;/f7-tab&gt; &lt;f7-tab route-tab-id=\"tab3\"&gt;&lt;/f7-tab&gt; &lt;f7-tab route-tab-id=\"tab4\"&gt;&lt;/f7-tab&gt;&lt;/f7-tabs&gt; 123456789101112131415161718192021222324//route.js&#123; path: '/navbarsAndToolbars/tabbar/', component: require('./pages/navbarsAndToolbars/tabbar.vue'), tabs: [ &#123; path: '/', tabId: 'tab1', component: require('./pages/navbarsAndToolbars/tab1.vue') &#125;, &#123; path: '/tab2/', tabId: 'tab2', component: require('./pages/navbarsAndToolbars/tab2.vue') &#125;, &#123; path: '/tab3/', tabId: 'tab3', component: require('./pages/navbarsAndToolbars/tab3.vue') &#125;, &#123; path: '/tab4/', tabId: 'tab4', component: require('./pages/navbarsAndToolbars/tab4.vue') &#125; ]&#125; 以上代码并不起作用，这段代码渲染后，在.page-content中渲染出来的f7-tab如下所示： 再查看framework7-vue中的tab.vue的源代码，发现tab标签是在渲染的时候通过比对$router中的tabId跟tab的id是否相同，若相同，则在f7-tab中渲染tabId对应的component 1234567891011121314151617181920212223//这里只取tab.vue中渲染的那段代码render: function (c) &#123; var self = this; const activeTab = self.routeInfo.activeTab; return c('div', &#123; staticClass: 'tab', attrs: &#123; id: self.id &#125;, class: &#123; 'active': (activeTab) ? activeTab.tabId === self.id : self.active &#125;, on: &#123; 'tab:show': self.onTabShow, 'tab:hide': self.onTabHide &#125; &#125;, //通过比对f7-tab标签的id和$router.tabId是否相同，相同则渲染对应的component [activeTab &amp;&amp; activeTab.tabId === self.id ? c(activeTab.component, &#123;tag: 'component', props: self.$route.params&#125;) : self.$slots.default] );&#125; 从上面的代码可以看出，f7-tab的内容时在页面跳转的时候进行渲染的，而通过tab-link进行tab页的切换只是修改f7-tab的类来显示对应的tab页，是无法显示其他tab页的内容的，需将tab-link改为route-tab-link，这样在tabbar中的a标签才会设置成active，而跳转则是通过href进行跳转，完整写法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//tabbar.vue&lt;template&gt; &lt;f7-page toolbar-fixed no-toolbar data-page=\"toolbar\"&gt; &lt;f7-navbar title=\"Tab Bar\" back-link=\"Back\" sliding&gt; &lt;f7-nav-right&gt; &lt;f7-link icon=\"icon icon-bars\" open-panel=\"left\"&gt;&lt;/f7-link&gt; &lt;/f7-nav-right&gt; &lt;/f7-navbar&gt; &lt;f7-toolbar tabbar&gt; &lt;f7-link route-tab-link=\"#tab1\" href=\"/navbarsAndToolbars/tabbar/\" active&gt; &lt;f7-icon f7=\"help\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"help_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab2\" href=\"/navbarsAndToolbars/tabbar/tab2/\"&gt; &lt;f7-icon f7=\"drawers\" class=\"inactive\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;f7-icon f7=\"drawers_fill\" class=\"active\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab3\" href=\"/navbarsAndToolbars/tabbar/tab3/\"&gt; &lt;f7-icon f7=\"cloud\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"cloud_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab4\" href=\"/navbarsAndToolbars/tabbar/tab4/\"&gt; &lt;f7-icon f7=\"camera\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"camera_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;/f7-toolbar&gt; &lt;f7-tabs&gt; &lt;f7-tab id=\"tab1\"&gt;&lt;/f7-tab&gt; &lt;f7-tab id=\"tab2\"&gt;&lt;/f7-tab&gt; &lt;f7-tab id=\"tab3\"&gt;&lt;/f7-tab&gt; &lt;f7-tab id=\"tab4\"&gt;&lt;/f7-tab&gt; &lt;/f7-tabs&gt; &lt;/f7-page&gt;&lt;/template&gt;&lt;style lang=\"less\"&gt;.page[data-page=\"toolbar\"]&#123; .page-content&#123; padding-bottom: 44px; &#125; .toolbar&#123; transform: none; transition: 0ms; .active-state&#123; opacity: 1; transition: 0ms; &#125; a.active&#123; i.inactive&#123; display: none; &#125; i.active&#123; margin-left: 0; color: #007aff; &#125; &#125; &#125; .tabbar&#123; a:not(.active)&#123; i.active&#123; display: none; &#125; &#125; &#125;&#125;&lt;/style&gt;//tab1.vue&lt;template&gt; &lt;p&gt;tab1&lt;/p&gt;&lt;/template&gt;//tab2.vue&lt;template&gt; &lt;p&gt;tab2&lt;/p&gt;&lt;/template&gt;//tab3.vue&lt;template&gt; &lt;p&gt;tab3&lt;/p&gt;&lt;/template&gt;//tab4.vue&lt;template&gt; &lt;p&gt;tab4&lt;/p&gt;&lt;/template&gt; 123456789101112131415161718192021222324//route.js&#123; path: '/navbarsAndToolbars/tabbar/', component: require('./pages/navbarsAndToolbars/tabbar.vue'), tabs: [ &#123; path: '/', tabId: 'tab1', component: require('./pages/navbarsAndToolbars/tab1.vue') &#125;, &#123; path: '/tab2/', tabId: 'tab2', component: require('./pages/navbarsAndToolbars/tab2.vue') &#125;, &#123; path: '/tab3/', tabId: 'tab3', component: require('./pages/navbarsAndToolbars/tab3.vue') &#125;, &#123; path: '/tab4/', tabId: 'tab4', component: require('./pages/navbarsAndToolbars/tab4.vue') &#125; ]&#125; 其实不用tab的层级路由，直接在tabbar.vue中引入Vue组件并将其放到对应的f7-tab的方式要方便多了 以上这种通过tab层级路由实现tabbar的方式，由于是在一个页面中，并且只有一个.page-content，所以当tab页滚动后，再切换到其他tab页时，此时的tab页的位置处于上一个tab页滚动后的位置。若要实现不同tab页滚动位置不同，可以将.page-content作为tab页，并使用多个.page-content，可查看相关文档：page中的 “Page Content as Tabs” 部分。记住，这时不能使用层级路由，就按照官方文档最初始的写法，代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;f7-page no-toolbar toolbar-fixed tabs no-page-content data-page=\"toolbar\"&gt; &lt;f7-navbar title=\"Diff Scroll Tab Bar\" back-link=\"Back\" sliding&gt; &lt;f7-nav-right&gt; &lt;f7-link icon=\"icon icon-bars\" open-panel=\"left\"&gt;&lt;/f7-link&gt; &lt;/f7-nav-right&gt; &lt;/f7-navbar&gt; &lt;f7-toolbar tabbar labels&gt; &lt;f7-link tab-link=\"#tab1\" no-link-class active&gt; &lt;f7-icon f7=\"help\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"help_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Information&lt;/span&gt; &lt;/f7-link&gt; &lt;f7-link tab-link=\"#tab2\" no-link-class&gt; &lt;f7-icon f7=\"drawers\" class=\"inactive\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;f7-icon f7=\"drawers_fill\" class=\"active\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Inbox&lt;/span&gt; &lt;/f7-link&gt; &lt;f7-link tab-link=\"#tab3\" no-link-class&gt; &lt;f7-icon f7=\"cloud\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"cloud_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Upload&lt;/span&gt; &lt;/f7-link&gt; &lt;f7-link tab-link=\"#tab4\" no-link-class&gt; &lt;f7-icon f7=\"camera\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"camera_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Photos&lt;/span&gt; &lt;/f7-link&gt; &lt;/f7-toolbar&gt; &lt;f7-page-content tab active id=\"tab1\"&gt;&lt;tab1&gt;&lt;/tab1&gt;&lt;/f7-page-content&gt; &lt;f7-page-content tab id=\"tab2\"&gt;&lt;tab2&gt;&lt;/tab2&gt;&lt;/f7-page-content&gt; &lt;f7-page-content tab id=\"tab3\"&gt;&lt;tab3&gt;&lt;/tab3&gt;&lt;/f7-page-content&gt; &lt;f7-page-content tab id=\"tab4\"&gt;&lt;tab4&gt;&lt;/tab4&gt;&lt;/f7-page-content&gt; &lt;/f7-page&gt;&lt;/template&gt; 12345678910&lt;script&gt;import Tab1 from './tab1'import Tab2 from './tab2'import Tab3 from './tab3'import Tab4 from './tab4'export default &#123; components: &#123; Tab1, Tab2, Tab3, Tab4 &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132&lt;style lang=\"less\"&gt;.page[data-page=\"toolbar\"]&#123; .page-content&#123; padding-bottom: 44px; &#125; .toolbar&#123; transform: none; transition: 0ms; .active-state&#123; opacity: 1; transition: 0ms; &#125; a.active&#123; i.inactive&#123; display: none; &#125; i.active&#123; margin-left: 0; color: #007aff; &#125; &#125; &#125; .tabbar&#123; a:not(.active)&#123; i.active&#123; display: none; &#125; &#125; &#125;&#125;&lt;/style&gt; framework7踩坑记（二）就更到这，后面继续更新基于framework7-vue实现的官方实例 vue-framework7，持续更新中，欢迎star","categories":[{"name":"webapp","slug":"webapp","permalink":"http://blog.ywulin.com/categories/webapp/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.ywulin.com/tags/vue/"},{"name":"framework7","slug":"framework7","permalink":"http://blog.ywulin.com/tags/framework7/"}]},{"title":"Framework7+Framework7-vue+vue踩坑记（一）","slug":"201707141526","date":"2017-07-14T07:27:13.000Z","updated":"2017-07-19T15:35:02.410Z","comments":true,"path":"201707141526.html","link":"","permalink":"http://blog.ywulin.com/201707141526.html","excerpt":"用vue来做webapp是很合适的，它有自己的路由和过渡，不过对于ios系统的侧滑返回功能，vue-router有点瑕疵，过渡动画会重复。故使用淘宝针对ios制作的framework7+vue来做webapp。framework7-vue出的时间不长，官网上描述不是特别详细，所以在这里使用vue+framework7-vue+framework7来重绘官网的demo。","text":"用vue来做webapp是很合适的，它有自己的路由和过渡，不过对于ios系统的侧滑返回功能，vue-router有点瑕疵，过渡动画会重复。故使用淘宝针对ios制作的framework7+vue来做webapp。framework7-vue出的时间不长，官网上描述不是特别详细，所以在这里使用vue+framework7-vue+framework7来重绘官网的demo。 网上关于framework7-vue的博客基本没有，所以我决定来踩波坑，以下是我在使用framework7-vue时遇到的一些需要注意的点 1、this指向在定时器和framework7的api回调函数中，this会被修改指向其他作用域，在定时器或回调api调用之前定义一个变量保存指向vue作用域的this 2、Autocomplete功能实现framework7-vue没有Autocomplete组件，需要自己手动实现，Autocomplete主要通过js进行配置和初始化，自定义选项较多。Autocomplete需要使用到f7-list组件作为输入的容器，代码如下： 123456&lt;f7-list form&gt; &lt;f7-list-item&gt; &lt;f7-label&gt;Fruit&lt;/f7-label&gt; &lt;f7-input type=\"text\" placeholder=\"Fruit\" id=\"autocomplete-dropdown\"&gt;&lt;/f7-input&gt; &lt;/f7-list-item&gt;&lt;/f7-list&gt; 此外还需要在vue的生命周期mounted中进行初始化tips：不能在created中进行初始化，这时候模板尚未编译挂载，无法将插件绑定到dom上 1234567891011121314151617181920212223242526data() &#123; return &#123; fruits: ('Apple Apricot Avocado Banana Melon Orange Peach Pear Pineapple').split(' ') &#125;&#125;mounted() &#123; //注意，这里在插件初始化中this并非指向Vue实例的 let fruits = this.fruits; let autocompleteDropdownSimple = window.f7.autocomplete(&#123; input: '#autocomplete-dropdown', openIn: 'dropdown', source: function (autocomplete, query, render) &#123; let results = [] if (query.length === 0) &#123; render(results) return &#125; for (let i = 0; i &lt; fruits.length; i++) &#123; if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) &gt;= 0) &#123; results.push(fruits[i]) &#125; &#125; render(results) &#125; &#125;)&#125; 其他类型的选项请参照官网原生文档实现：http://docs.framework7.cn/Index/autocomplete.html 3、this.$$ &amp; this.Dom7 中无jsonp请求在this.$$中无jsonp请求，若要使用jsonp，可安装vue-resource（不过该插件作者已宣布不再更新），用法一样 4、Calendar / Datepickerframework7-vue没有Calendar / Datepicker的组件，需要手动实现，跟Autocomplete一样，代码如下 123456789&lt;template&gt; &lt;f7-page&gt; &lt;f7-list form&gt; &lt;f7-list-item&gt; &lt;f7-input type=\"text\" placeholder=\"Select date\" readonly id=\"calendar-disabled\"&gt;&lt;/f7-input&gt; &lt;/f7-list-item&gt; &lt;/f7-list&gt; &lt;/f7-page&gt;&lt;/template&gt; 123456789&lt;script&gt;export default&#123; mounted () &#123; let calendarDefault = this.$f7.calendar(&#123; input: '#calendar-default' &#125;) &#125;&#125;&lt;/script&gt; 5、Contactsframework7-vue中有contacts-list组件，其.list.group-title在谷歌浏览器调试时，position: sticky中top是相对于viewport定位的，所以滚动后处于浏览器顶部，被navbar遮住，但在手机上是正常显示的，其top是相对于.page-content定位的 6、层级路由framework7-vue在本文章撰写时除了在同页面Tab中有层级路由外，没有实现页面间的层级路由，跟vue-router不一样，要实现页面间的层级跳转，路由的写法跟平时写法一致，直接跳转即可，如下 123456789101112131415[ &#123; path: '/floatingAction/', component: require('./pages/floatingAction/floatingAction.vue'), &#125;, &#123; //我这里为了显示出层级关系，将其上一级页面的路由也包含进去，事实上是可以不用这么做的 path: '/floatingAction/staticFloating/', component: require('./pages/floatingAction/staticFloating.vue') &#125;, &#123; path: '/floatingAction/speedDial/', component: require('./pages/floatingAction/speedDial.vue') &#125;] 7、f7-input: type=”select”f7-input中设置type=&quot;select&quot;，不会有默认选中项，需要在f7-input中绑定v-model=&quot;selected&quot;，而给option设置selected属性是不会显示选中项的 8、无限滚动Infinite Scroll无限滚动的实现是在f7-page中加上infinite-scroll，滚动事件为@infinite=&quot;doSomething&quot;，页面每次变更都需要重新刷新一次浏览器，否则infinite事件不会绑定，infinite-scroll是在page:init即页面初始化时初始化的，而热加载不会重新执行一遍page:init。以下是代码实现： 12345678910111213&lt;template&gt; &lt;f7-page infinite-scroll @infinite=\"onInfiniteScroll\"&gt; &lt;f7-navbar title=\"Infinite Scroll\" back-link=\"返回\" sliding&gt; &lt;f7-nav-right&gt; &lt;f7-link icon=\"icon icon-bars\" open-panel=\"left\"&gt;&lt;/f7-link&gt; &lt;/f7-nav-right&gt; &lt;/f7-navbar&gt; &lt;f7-block-title&gt;SCROLL BOTTOM&lt;/f7-block-title&gt; &lt;f7-list&gt; &lt;f7-list-item v-for=\"item in items\" :title=\"'Item ' + item\"&gt;&lt;/f7-list-item&gt; &lt;/f7-list&gt; &lt;/f7-page&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334&lt;script&gt;export default &#123; data () &#123; return &#123; items: 20, loading: false, maxLength: 60 &#125; &#125;, methods: &#123; onInfiniteScroll: function () &#123; if (this.loading) &#123; return; &#125; this.loading = true; let _this = this; setTimeout(function () &#123; _this.loading = false; if (_this.items &gt;= _this.maxLength) &#123; _this.$f7.detachInfiniteScroll(_this.$$('.infinite-scroll')) _this.$$('.infinite-scroll-preloader').remove() return &#125; _this.items += 20; &#125;, 1000) &#125; &#125;&#125;&lt;/script&gt; 9、f7-list的灵活性f7-list的比较灵活，严格来说应该是f7-list-item比较灵活，自由度高，该组件在设计时添加了不少slot选项来分发内容 灵活运用slots可以实现各种列表效果，如以下效果： 代码的实现如下： 1234567891011121314151617181920212223242526&lt;f7-list-item title=\"No icons here\"&gt; &lt;ul slot=\"root\"&gt; &lt;f7-list-item link=\"#\" media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"Ivan Petrov\" after=\"CEO\" &gt;&lt;/f7-list-item&gt; &lt;f7-list-item link=\"#\" media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"Two icons here\" &gt;&lt;/f7-list-item&gt; &lt;f7-list-item title=\"No icons here\"&gt;&lt;/f7-list-item&gt; &lt;f7-list-item link=\"#\" media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"Ultra long text goes here, no, it is really really long\" &gt;&lt;/f7-list-item&gt; &lt;f7-list-item media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"With switch\"&gt; &lt;f7-input type='switch' slot=\"after\"&gt;&lt;/f7-input&gt; &lt;/f7-list-item&gt; &lt;/ul&gt;&lt;/f7-list-item&gt; 10、$router要在javascript中使用路由$router，用法为this.$router，$router是保存在vue作用域中的 framework7-vue的注意点目前就写到这，后面继续更新基于framework7-vue实现的官方实例 vue-framework7，持续更新中，欢迎star","categories":[{"name":"webapp","slug":"webapp","permalink":"http://blog.ywulin.com/categories/webapp/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.ywulin.com/tags/vue/"},{"name":"framework7","slug":"framework7","permalink":"http://blog.ywulin.com/tags/framework7/"}]},{"title":"gulp自动化构建工具学习","slug":"201706251602","date":"2017-06-25T08:02:45.000Z","updated":"2017-06-25T08:20:09.953Z","comments":true,"path":"201706251602.html","link":"","permalink":"http://blog.ywulin.com/201706251602.html","excerpt":"Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。在这里介绍了gulp的入门，插件和gulpfile.js配置文件。","text":"Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。在这里介绍了gulp的入门，插件和gulpfile.js配置文件。 入门 全局安装gulp $ npm install -g gulp 新建一个文件夹作为项目，进入该文件夹，初始化 $ mkdir example $ npm init 安装开发依赖（devDependences） $ npm install --save-dev gulp 在项目根目录新建 gulpfile.js 文件 $ touch gulpfile.js 编辑gulpfile.js文件 12345var gulp = require('gulp'); gulp.task('default', function () &#123; //默认任务代码 &#125;); 命令行运行gulp，即可运行默认任务 $ gulp api介绍 这里只列出api常用用法，了解更多请查阅官网http://www.gulpjs.com.cn/docs/api/ gulp.src(globs[, options]) 输出符合匹配的文件并返回一个stream，可pipe到其他插件 golbs(类型：String或Array) String: ‘src/js/*.js’Array: [‘src/js/*.js’, ‘src/css/*.css’] gulp.dest(path[, options]) 将pipe进来的数据转存为指定文件夹下的文件，若指定文件夹不存在，则自动创建该文件夹 path(类型：String或Function) String: ‘dist/js’Function: 在函数中返回相应路径 gulp.task(name[, deps], fn) 定义一个任务 123gulp.task('something', functio () &#123; doSomething();&#125;); name(类型：String) 任务的名字，可在命令行中通过name运行任务，$ gulp name deps(类型：Array) 一个包含任务列表的数组，这些任务会在当前任务运行之前完成 fn(类型：Function) 该任务要执行的内容 gulp.watch(glob[, opts], tasks) 或 gulp.watch(globs[, opts, cb]) 文件监视，当指定匹配文件发生变化时，执行tasks或函数cb glob(类型：String或Array) tasks(类型：String或Array) 文件变动后执行之前定义好的任务 cb(类型： Function) 传入一个记录文件变动的event对象，event.type记录变动类型：added, changed, deleted；event.path记录变动文件的路径 gulp插件介绍 gulp-less/gulp-sass 预编译less/sass文件为css文件 安装：$ npm install --save-dev gulp-less gulp-autoprefixer 设置浏览器版本，css文件自动添加浏览器前缀 安装：$ npm install --save-dev gulp-autoprefixer gulp-minify-css 压缩css文件 安装：$ npm install --save-dev gulp-minify-css gulp-rename 重命名要输出的文件，如将.css重命名为.min.css 安装：$ npm install --save-dev gulp-rename vinyl-buffer 将vinyl对象内容中的stream转换为buffer 安装：$ npm install --save-dev vinyl-buffer vinyl-source-stream 将Browserify的bundle()的输出转换为Gulp可用的vinyl流 安装：$ npm install --save-dev vinyl-source-stream gulp-sourcemaps 编写内联sourcemaps 安装：$ npm install --save-dev gulp-sourcemaps browserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，在这里用来管理依赖 安装：$ npm install --save-dev browserify babelify 将ES6转换成ES5 安装：$ npm install --save-dev babelify gulp-uglify 压缩 JavaScript 文件 安装：$ npm install --save-dev gulp-uglify gulp-imagemin 压缩 png，jpeg，gif和svg图片资源 安装：$ npm install --save-dev gulp-imagemin gulp-cache 图片缓存，只有图片替换了才压缩 安装：$ npm install --save-dev gulp-cache gulp-clean 移除文件或文件夹 安装：$ npm install --save-dev gulp-clean gulp-util 包含gulp的一些实用功能，在这里用来打印编译错误 安装：$ npm install --save-dev gulp-util gulp-notify 当文件变更时提醒 安装：$ npm install gulp-notify gulp-connect gulp中用来运行服务器的插件，内含LiveReload，自动刷新浏览器 安装：$ npm install --save-dev gulp-connect gulpfile.js文件配置 内含 ES6 转 ES5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var gulp = require('gulp'), less = require('gulp-less'), autoprefixer = require('gulp-autoprefixer'), minifycss = require('gulp-minify-css'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), rename = require('gulp-rename'), clean = require('gulp-clean'), cache = require('gulp-cache'), notify = require('gulp-notify'), browserify = require('browserify'), babelify = require('babelify'), buffer = require('vinyl-buffer'), source = require('vinyl-source-stream'), sourcemaps = require('gulp-sourcemaps'), gutil = require('gulp-util'), connect = require('gulp-connect');/* * styles任务，将'src/less'目录下的less文件转换成css文件， * 并加上浏览器前缀，存放于'dist/css'目录下，之后重命名加上.min，压缩， * 保存为.min.css文件，之后刷新浏览器，并提醒style任务完成 */gulp.task('styles', function() &#123; return gulp.src('src/less/*.less') .pipe(less()) .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4')) .on('error', gutil.log) .pipe(gulp.dest('dist/css')) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('dist/css')) .pipe(connect.reload()) .pipe(notify(&#123;message: 'style task complete'&#125;);&#125;);/* * scripts任务，通过browserify设置入口文件，然后用babelify将 * es6转换成es5，保存在'dist/js'目录下，之后压缩js文件，重命名 * 保存为.min.js文件 */gulp.task('scripts', function() &#123; var b = browserify(&#123; entries: 'src/js/cart.js', debug: true &#125;); return b.transform(babelify.configure(&#123; presets: [\"es2015\"] &#125;)) .bundle() .on('error', gutil.log) .pipe(source('cart.js')) .pipe(gulp.dest('dist/js')) .pipe(buffer()) .pipe(sourcemaps.init(&#123;loadMaps: true&#125;)) .pipe(uglify()) .on('error', gutil.log) .pipe(sourcemaps.write('./')) .pipe(rename(&#123; suffix: '.min'&#125;)) .pipe(gulp.dest('dist/js')) .pipe(connect.reload());&#125;);/* * images任务，读取'src/img'目录下的图片，压缩并保存到'dist/img'目录下 */gulp.task('images', function() &#123; return gulp.src('src/img/*') .pipe(cache(imagemin([ imagemin.gifsicle(&#123;interlaced: true&#125;), imagemin.jpegtran(&#123;progressive: true&#125;), imagemin.optipng(&#123;optimizationLevel: 5&#125;), imagemin.svgo(&#123;plugins: [&#123;removeViewBox: true&#125;]&#125;)]))) .on('error', gutil.log) .pipe(gulp.dest('dist/img')) .pipe(connect.reload());&#125;);/* * html任务，读取'src'目录下的html文件，并保存到'dist'目录下 */gulp.task('html', function() &#123; return gulp.src('src/shangcheng/*.html') .pipe(gulp.dest('dist/')) .pipe(connect.reload());&#125;);/* * connect任务，运行服务器并自动刷新浏览器 */gulp.task('connect', function() &#123; connect.server(&#123; livereload: true &#125;);&#125;);/* * clean任务，将dist目录下的css文件，js文件，图片文件和html文件清除 */gulp.task('clean', function() &#123; return gulp.src(['dist/css', 'dist/js', 'dist/img', 'dist/*.html'], &#123;read: false&#125;) .pipe(clean());&#125;);/* * 默认任务，在开始执行styles任务，scripts任务，images任务，html任务 * 之前先执行clean任务 */gulp.task('default', ['clean'], function() &#123; gulp.start('styles', 'scripts', 'images', 'html');&#125;);/* * 监视任务，监听less文件，js文件，图片文件和html文件的变更 */gulp.task('watch', function() &#123; //监听所有.less gulp.watch('src/less/*.less', ['styles']); //监听所有.js文件 gulp.watch('src/js/*.js', ['scripts']); //监听所有图片文件 gulp.watch('src/img/*', ['images']); //监听html文件 gulp.watch('src/*.html', ['html']);&#125;);/* * server任务，执行connect任务和watch任务 */gulp.task('server', ['connect', 'watch']); 不含 ES6 的 js 文件任务 1234567891011gulp.task('scripts', function() &#123; return gulp.src('src/js/*.js') .pipe(gulp.dest('dist/js')) .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(sourcemaps.init(&#123;loadMaps: true&#125;)) .pipe(uglify()) .pipe(sourcemaps.write('./')) .on('error', gutil.log) .pipe(gulp.dest('dist/js')) .pipe(connect.reload());&#125;);","categories":[{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://blog.ywulin.com/categories/自动化构建工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://blog.ywulin.com/tags/gulp/"}]}]}