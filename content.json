{"meta":{"title":"涯无凌","subtitle":"一枚渣渣前端工程师","description":"涯无凌的个人博客","author":"涯无凌","url":"http://blog.ywulin.com"},"pages":[{"title":"about","date":"2017-07-23T09:57:50.000Z","updated":"2017-07-23T09:57:50.320Z","comments":true,"path":"about/index.html","permalink":"http://blog.ywulin.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"前端技术就我目前已知的汇总","slug":"201709102311","date":"2017-09-11T10:40:55.000Z","updated":"2018-04-06T09:04:21.763Z","comments":true,"path":"201709102311.html","link":"","permalink":"http://blog.ywulin.com/201709102311.html","excerpt":"目前前端的技术很多，范围也很广，在这篇博客就我目前所知道的前端技术做个汇总，有些我也还没看过，在这里不会细谈，这篇博客会持续更新下去","text":"目前前端的技术很多，范围也很广，在这篇博客就我目前所知道的前端技术做个汇总，有些我也还没看过，在这里不会细谈，这篇博客会持续更新下去 这里把分成前端和后端（Node），如果有什么地方讲的不对，欢迎指教，谢谢 一、前端 1、ECMAScript ECMAScript : JavaScript 的标准，目前已发布到 ECMAScript 2017 了（这三年一年发布一个版本，除了 ES6 更新幅度很大，后面的两个版本都只是新增了部分语法或语法糖），文档是阮一峰老师写的《ECMAScript 6 入门》，讲的很详细，持续更新中，另外 Babel 这里给的 文档 比较简短，适合查询用 2、Babel，让你使用下一代 JavaScript 标准 Babel : 由于 ECMAScript 的新语法有些在浏览器上还没有被实现，所以 Babel 诞生了，它可以让你使用最新的 JavaScript 标准，并帮你自动将其转换为 ES5 3、JavaScript 转译语言 CoffeeScript : 一门编译到 JavaScript 的小巧语言 TypeScript : 微软开发的一种编程语言，是 JavaScript 的一个超集，扩展了 JavaScript 的语法 4、强大的构建工具 如果你还在自己手动地重复检查，合并，压缩，格式化文件，刷新浏览器这些枯燥的工作，那么你可以来尝试一下构建工具（选择自己喜欢的就好） rollup : 中文文档 点击这里 Grunt : 中文文档 点击这里 Gulp : 中文文档 点击这里 webpack : 中文文档 点击这里 Browserify 5、ESlint JS代码检测 ESlint 定义了一套代码风格的规则，使用它可以让你的代码更具有可读性，适用于团队合作，以下是目前比较流行的两套 ESlint 标准 standard style Airbnb JavaScript Style Guide 6、stylelint，CSS 代码检测 stylelint : 一个强大的现代 CSS 检测器，可以让你在样式表中遵循一致的约定和避免错误，中文文档 点击这里 7、不可缺少的测试 一个项目，一个工具，一个插件，如果你不做测试，那么其稳定性无法保证 karma : 测试管理工具 mocha : 单元测试框架，可跟 karma 结合 jasmine : 单元测试框架，可跟 karma 结合 Nightwatch : 端对端测试框架，模拟用户行为的测试 CasperJS : 端对端测试框架，基于 PhantomJS Protractor : AngularJS 的端对端测试框架 8、优秀的 JavaScript 代码库 —— jQuery &amp;&amp; Zepto jQuery : 提供了一系列方便的 API ，包含选择器，Dom 处理，JS 动画，事件处理等，兼容性好。个人喜欢使用这个 文档 ，一个 jQuery 速查表 Zepto : Zepto 是一个更轻量级的代码库，保留了 jQuery 的大部分 api 名字，同时对移动端做了适配，适合用于移动端开发 9、Web框架 这几个框架中我目前就用到了 Vue，React 正在学习，其他的尚未使用，这里我会对 Vue 的篇幅多一点，抱歉，若有什么讲的不对的，请帮忙指正 Vue : 尤雨溪大大开发的一个轻量的 MVVM 框架，目前在国内很火，很多大厂也开始用 Vue 重构项目了 Vue 社区 : https://www.vue-js.com/ ，可在这里寻找开源项目练手Github上面基于 Vue 的项目 : https://github.com/vuejs/awesome-vue Vue 全家桶 Vue-Router : Vue 官方路由插件 Vuex : Vue 官方状态管理插件 axios : Vue 官方推荐 HTTP 客户端 基于 Vue 的 UI 组件库 Mint-UI : 饿了么开源的一个适用于移动端的 UI 组件库，样式简洁 Muse-UI : 一款运用了 Google 的 Material Design 设计理念的UI组件库 Vue-Material : 一款运用了 Google 的 Material Design 设计理念的UI组件库 Vux : 基于微信开源的 WeUI 进行开发的一套 Vue 组件库，封装好了微信的 jssdk，很适合开发用于微信的移动端网页 Element UI : 饿了么开源的 Vue 组件库，比较适合用于 PC 端网页的开发 除了以上所列出的组件库，还有其他不少优秀的组件库，这里不再陈列了 React : Facebook 开源的一款用于 UI 的 JS 库，社区很活跃，语法不多（相比较于 Vue），性能出众，代码逻辑非常简单（套用阮一峰老师的话），中文文档 点击这里 Angular : Google 开发的一个 MVVM 框架，曾经的 AngualarJS 1.0 其 watcher 越多会导致项目越慢，它使用了脏检查循环。你会发现 Vue 的一些语法跟 Angular 很像，因为 Angular 是 Vue 早期开发的灵感来源。现在 AngularJS 已经升级到2.0了，代码优化了不少，性能也改进了 以上框架的对比，详细查看 https://cn.vuejs.org/v2/guide/comparison.html ，至于选择哪种框架看个人喜好，没有什么最好的，只有最适合自己的 CycleJS : 一个函数式和响应式的 JavaScript 框架，编写可观测代码 10、CSS 预处理器，提高你工作效率的好工具 css 预处理器的思想是用一种专门的编程语言来编写样式表，之后再将其编译成 css 文件 Sass / Scss : 基于 Ruby 编译，Scss 是Sass 3 引入的新的语法，兼容 CSS3，并继承了 Sass 的功能，Scss 语法对 CSS 友好，目前说 Sass，基本用的是 Scss 语法，插件也基本都是面向 Scss 的。编译的时候得安装 Ruby，或者使用 koala 这个工具，如果你是使用 webpack 等打包工具的话，有对应的插件可以使用，VSCode 等编辑器也有对应的插件。中文文档 点击这里 Less : 基于 Node 编译的预处理器，语法没 Sass 那么多，但用起来也比较舒服，看个人喜欢了。 Stylus : 基于 Node 编译的 CSS 预处理器，语法很强大，语法点多，写法有多种，很自由，在我制作 Hexo 博客主题的时候使用了其部分语法，刚学的时候可能无法驾驭住 以上预处理器各有优缺点，至于选择哪一种，同样的没有最好的，只有最适合自己的 11、Web APP 运行于移动端网页上，具备移动 APP 的部分特点，即使用网页实现的 APP，但不具备调用所有手机底层 API 的能力（曾经我有段时间将 web app 理解成了 Hybrid APP），以下介绍部分能用于开发 Web APP 的框架，部分使用过的框架会篇幅多一点 Vue + Vue-router + Vuex + axios( + UI组件库) : Vue 的官方插件 Vue-router 可以实现路由跳转，Vuex可以用于存储登录状态等，axios 获取数据，再加上UI组件库可以帮你方便地构建出一款Web APP，Vue 的transition标签可以实现路由跳转动画。这里使用了前后端分离的思想，了解前后端分离，请走传送门：前后端分离。登录状态安全性请去了解Token机制和 Web本地存储（本地存储下面会简单介绍一下） jQuery mobile : jQuery 框架的一个组件 Frozen UI : 一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件，做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中（官方原话） ionic : 基于 Sass 和 Angular 的一个开源组件库，官方文档需要翻墙访问，可以阅读中文文档 点击这里 Amaze UI : 一个轻量级的用于移动端的框架 Framework7 : 淘宝开源的一个移动端组件库，分 iOS 样式和 Android 样式，它的理念是致力于打造接近原生的体验，实现了 iOS 的侧滑返回功能，所以很逼近 iOS 原生体验，它构建了一个轻量的 jQuery 语法框架，并基于其进行开发。该框架同时有适配 Vue 的 Framework7-Vue 和适配 React 的 Framework7-React，关于 Framework7-Vue，我用它重构了 Framework7 官网的 Demo，Github 的地址在这：vue-framework7，并对其遇到的一些问题写了几篇博客，请走 传送门（Framework7 的文档分了好几个域名展示，每个文档的更新程度不一致，以上所展示的地址是一直保持着最新内容，其他链接目前没有更新了） Web APP 的框架很多，你可以自己去搜索，以上就只列了部分而已 12、Hybrid APP Hybrid APP ，译为混合 APP，即部分地方采用原生，部分地方使用 Web APP，现在有很多 APP 都采用这种开发模式，Web APP可以一套代码适用 iOS 和 Android 双平台，所以开发周期快，比如手Q就是这种开发模式，上面陈列的 Web APP 在外面包个壳就可以打包成 APP 了 Cordova : 一个 Web APP 打包工具，是 Phonegap 捐赠给 Apache 后使用的项目名，它给 Web 提供了一个 Web 容器供其运行，官方提供了调用手机底层 API 插件，能实现多端打包，此外还有不少用户开发封装的第三方插件，以上提及的 Web APP 框架基本可用该工具打包成 APP Angular + ionic + Phonegap : 目前比较流行的 Hybrid APP 开发技术选型，ionic 提供了很多方便好用的功能 Vue + Framework7-Vue + Cordova : Vue 的 Hybrid APP 之路比较短，目前没有常见的技术选型，以上是我实践过后的技术选型，在 iOS 上可以达到以假乱真的程度，在 Android 上的话还需要加上 crosswork 这个工具，才不至于太卡，另外转场动画可能会比较单一（Vue 的 transition 在使用手机的返回时会重新执行一遍动画） H5+ + MUI : H5+ 是 DCloud 提出的一套标准，它可以让我们使用 JS 调用手机底层40万 API，API 使用起来简单，MUI 是官方配套的一套组件库，配合官方编辑器 HBuilder 可以很方便地进行远程打包安装。2017年3月份我使用的时候它的社区还不是很完善，按照其他人的评价就是社区大多是张口问问题，但分享的却很少，现在不知道怎么样（这里我自觉惭愧，我也曾经当过其中的一员，后面项目结束后想着把遇到的问题的解决方案分享出来的，拖着拖着就已经把内容忘了）。总结起来就是用法很简单，但部分技术问题没有提供解决措施。 13、使用前端技术来构建原生 APP 以下都需要具备一定的原生知识 React Native : 按照我的理解，React Native 是使用 React 的写法去调用原生组件，只不过 React 是调用 HTML 标签，虽然说 React Native 可以用一套代码实现 iOS 和 Android 双端，但大多数时候还是得写两套代码。曾经 React Native 最大的优势是热更新（热更新这里自己去查，我没用过，也不怎么了解），不过目前已被苹果给禁了，基于 React Native 的项目依旧可以过审。React Native 社区是目前最活跃的，很多坑也已经被踩平了，可以放心用。 Weex，又叫 Vue Native : 阿里开源的一个基于 Vue 语法的框架，一套代码使用于 PC，APP，Web 三端，2017年发布的，目前文档还在完善中，社区还不活跃，Vue 的开发者尤雨溪大大参与了该项目，并发布了一个用 weex 开发的 APP NativeScript : 国外开发者自行发起的一个开源项目，所以没有大厂做靠背，它的理念是使用 JavaScript 构建原生，其定义了一系列标签，用于同时适配 iOS 和 Android，所以构建出来的项目就是原生，不过目前标签还不完善，部分组件还未实现，它跟 Angular 和 Vue 不冲突，目前已有人实现了 NativeScript 和 Angular 和 Vue 的结合 14、前端也能圆桌面程序梦 Electron : Github 开源的一个打包工具，Atom 和 VSCode 都是用这个工具开发的，他可以将你编写的 Web 打包成三端（Windows，Mac，Linux）的安装程序。该工具使用了 Chrome V8 引擎用于渲染界面，本身提供了一些 API，同时我们也可以使用 Node 的 API。该工具有与 Vue 结合使用的初始化模块和文档，UI 框架可以选用 Element UI。中文文档 点击这里 15、前后端分离的数据模拟 MockJS : 前后端分离的开发模式，前端与后端先约定好数据格式和 API，在后端 API 还没封装好时，我们可以使用 MockJS 生成随机数据进行开发，提高工作效率 16、JS 模块规范 在 ES6 还没出来之前，JS 在浏览器方面没有模块规范（后端 Node 有 CommonJS 标准），以下是目前浏览器端的两个模块规范 AMD : 异步模块定义 CMD : 大名远扬的玉伯提出的规范，并根据其标准写了个 sea.js （CMD找不到官方文档） ES6 : ES6 标准提供了模块的定义，使用export导出模块的内容，使用import引入想要使用的模块 17、浏览器本地存储 localstorage : 没有时间限制的数据存储，一般浏览器支持的是 5M 大小，以键值对的形式存储 sessionstorage : 针对一个 session 的数据存储，只存在于当前会话，页面关闭或者浏览器关闭即消失 cookie : 有时间限制的数据存储 webSQL : 本地关系型数据库，目前已不再更新，浏览器一般支持 5M indexDB : 本地非关系型数据库，浏览器一般支持 5M 18、微信小程序 微信小程序 : 基于微信的程序，语法有点像 Vue 19、PWA PWA : 谷歌和百度联合推出的一门技术，能使你的 Web APP 表现得就像是 native mobile APP （官方文档需要翻墙，这里可以访问简书作者 “短衣匹马” 的译文） 二、后端 Node Node 是后端的领域了，目前我了解的不多，暂时没有余力去成为全栈工程师，以下简单地罗列我所了解的 1、Node Node : 使用 JavaScript 作为开发语言，并对其进行扩展，前端工程师能够快速入手，中文文档 点击这里 2、NPM NPM : Node 的包管理工具，由于 NPM 的仓库是架设在国外服务器上的，在国内下载速度慢，可以使用淘宝搭建的仓库，它实时保持着与官方仓库的一致，淘宝提供的包管理工具cnpm，安装依赖包的时候使用cnpm，构建项目的时候还是使用npm 3、CommonJS 规范 CommonJS ： 是 Node 提出的 JS 模块规范，使用export导出模块的内容，使用require引入想要使用的模块 4、Web 后台框架 express : 其针对 Node 的 http 模块封装了一系列 API，将底层实现好了，它让我们不再需要自己去实现底层逻辑，只需要专注于业务的实现，express 同时也提供了 https 请求机制 koa : express 原班人马打造，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 Web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。（取自koa中文文档） 5、模板引擎 node 作为后端，返回给浏览器的是静态文件，它没有 Java 的 jsp 服务器页面，所以就有了模板引擎，通过 node 提供的 文件操作 api 读取文件的内容，然后将数据替换到对应的位置，模板引擎也可用于客户端开发，以下只罗列几个，更多的模板引擎请自行搜索 Jade Mustache EJS 6、数据库 数据库我目前就了解 MongoDB 而已，以下也只列这一个 MongoDB : 一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库（来自菜鸟教程） 前端路漫漫，离全栈工程师还有一段路要走","categories":[],"tags":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"http://blog.ywulin.com/tags/前端杂谈/"}]},{"title":"Framework7+Framework7-vue+vue踩坑记（三）","slug":"201707240917","date":"2017-07-27T02:17:19.000Z","updated":"2018-04-06T09:00:21.813Z","comments":true,"path":"201707240917.html","link":"","permalink":"http://blog.ywulin.com/201707240917.html","excerpt":"接上一篇博客“Framework7+Framework7-vue+vue踩坑记（二）”，这里继续 framework7 + vue + framework7-vue 踩坑第三波。","text":"接上一篇博客“Framework7+Framework7-vue+vue踩坑记（二）”，这里继续 framework7 + vue + framework7-vue 踩坑第三波。 1. Notification组件framework7-vue没有该组件，使用framework7的方式实现，代码如下： 1234this.$f7.addNotification(&#123; title: 'Framework7', message: 'This is a simple notification message with title and message'&#125;) 2. picker组件framework7-vue没有该组件，使用framework7的方式实现，代码如下： 123456&lt;f7-list form&gt; &lt;f7-list-item&gt; &lt;f7-input type=\"text\" placeholder=\"Your iOS device\" id=\"picker-device\"&gt; &lt;/f7-input&gt; &lt;/f7-list-item&gt;&lt;/f7-list&gt; 123456789101112131415161718192021222324252627&lt;script&gt;export default &#123; mounted () &#123; let pickerDevice = this.$f7.picker(&#123; input: '#picker-device', cols: [ &#123; textAlign: 'center', values: [ 'iPhone 4', 'iPhone 4S', 'iPhone 5', 'iPhone 5S', 'iPhone 6', 'iPhone 6 Plus', 'iPad 2', 'iPad Retina', 'iPad Air', 'iPad mini', 'iPad mini2', 'iPad mini3'] &#125; ] &#125;) &#125;&#125;&lt;/script&gt; 3. 下拉刷新下拉刷新是在f7-page中加上pull-to-refresh，以下是代码实现： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;f7-page pull-to-refresh @ptr:refresh=\"onRefresh\"&gt; &lt;f7-navbar title=\"Pull To Refresh\" back-link=\"Back\" slding&gt; &lt;f7-nav-right&gt; &lt;f7-link icon=\"icon icon-bars\" open-panel=\"left\"&gt;&lt;/f7-link&gt; &lt;/f7-nav-right&gt; &lt;/f7-navbar&gt; &lt;f7-list media-list&gt; &lt;f7-list-item v-for=\"item in items\" :media=\"item.media\" :title=\"item.title\" :subtitle=\"item.subtitle\" &gt;&lt;/f7-list-item&gt; &lt;f7-list-label&gt; &lt;p&gt; &lt;div&gt;Just pull page down to let the magic happen.&lt;/div&gt; &lt;div&gt; Note that pull-to-refresh feature is optimised for touch and native scrolling so it may not work on desktop browser. &lt;/div&gt; &lt;/p&gt; &lt;/f7-list-label&gt; &lt;/f7-list&gt; &lt;/f7-page&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script&gt;export default &#123; data () &#123; return &#123; items: [ &#123; media: '&lt;img src=\"./static/image/photo12.jpg\" width=\"44\" /&gt;', title: 'Yellow Submarie', subtitle: 'Beatles' &#125;, &#123; media: '&lt;img src=\"./static/image/photo13.jpg\" width=\"44\" /&gt;', title: 'Don\\'t Stop Me Now', subtitle: 'Queen' &#125;, &#123; media: '&lt;img src=\"./static/image/photo14.jpg\" width=\"44\" /&gt;', title: 'Billie Jean', subtitle: 'Michael Jackson' &#125; ] &#125; &#125;, methods: &#123; onRefresh: function () &#123; let self = this setTimeout(function () &#123; let songs = [ 'Yellow Submarine', 'Don\\'t Stop Me Now', 'Billie Jean', 'Californication' ] let authors = [ 'Beatles', 'Queen', 'Michael Jackson', 'Red Hot Chili Peppers' ] let item = &#123; media: '&lt;img src=\"./static/image/photo' + Math.floor(Math.random() * 14) + '.jpg\" width=\"44\" /&gt;', title: songs[Math.floor(Math.random() * songs.length)], subtitle: authors[Math.floor(Math.random() * authors.length)] &#125; self.items.unshift(item) self.$f7.pullToRefreshDone() &#125;, 2000) &#125; &#125;&#125;&lt;/script&gt; 4. View间链接将在 left view 中的链接加载的页面放进 main view中，在 a 标签上加上 data-view=&quot;###&quot; （###为css选择器）即可 5. sortable list在f7-list的sortable属性为true时，通过v-for=&quot;item in items&quot;循环渲染列表，触发@sortable:sort事件时，不能对items进行操作，framework7-vue中sortable并没有操作items，而是对Dom树的操作，而v-for是先完成virtual dom树的修改再比对修改前的virtual dom树，然后对Dom树只修改变化的部分，而不是重排，这样会导致Dom树的列表又再一次按照我们之前的操作排列一次 6. f7-swiper该组件使用nested布局时无法正常显示导航条，使用原生实现，主要是该vue组件将f7-swiper中的内容全放到.swiper-wrapper中，因此就算自定义导航条的css选择器也无法正常显示 至此，官网的demo已重构完毕，目前发现的需要注意的点就这些。 使用 framework7-vue 重构后的项目地址：vue-framework7，欢迎star 项目初始化时，framework7 的参数中，cache 设置为 false 无效，原因未知。","categories":[{"name":"webapp","slug":"webapp","permalink":"http://blog.ywulin.com/categories/webapp/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.ywulin.com/tags/vue/"},{"name":"framework7","slug":"framework7","permalink":"http://blog.ywulin.com/tags/framework7/"}]},{"title":"Framework7+Framework7-vue+vue踩坑记（二）","slug":"201707171854","date":"2017-07-19T15:38:44.000Z","updated":"2018-04-06T09:00:24.925Z","comments":true,"path":"201707171854.html","link":"","permalink":"http://blog.ywulin.com/201707171854.html","excerpt":"接上一篇博客“Framework7+Framework7-vue+vue踩坑记（一）”，这里继续framework7+vue+framework7-vue踩坑第二波，同样通过重构官网demo来运用framework-vue。","text":"接上一篇博客“Framework7+Framework7-vue+vue踩坑记（一）”，这里继续framework7+vue+framework7-vue踩坑第二波，同样通过重构官网demo来运用framework-vue。 1. f7-message组件图片显示问题f7-message中无法在信息的text属性中使用&lt;img src=&quot;##&quot;&gt;标签，因为vue的模板语法是将html标签直接转换成字符串的，而在这篇博客编写时官方文档也没给出f7-messages中如何插入图片，如要实现以下效果 实现代码如下： 1234567891011121314&lt;f7-messages&gt; &lt;f7-message v-for=\"message in messages\" :text=\"message.text\" :label=\"message.label\" :date=\"message.date\" :name=\"message.name\" :avatar=\"message.avatar\" :type=\"message.type\" :day=\"message.day\" :time=\"message.time\" &gt; &lt;img v-if=\"message.img\" :src=\"message.img\" /&gt; &lt;/f7-message&gt;&lt;/f7-messages&gt; 我们可以看到f7-message的源代码中有一个不具名slot，所以父组件的内容会被插入到该slot所在的Dom位置，这一点是官方文档所没有说明的 123456789101112131415&lt;template&gt; &lt;div :class=\"classesObject\" @click=\"onClick\"&gt; &#123;&#123;day&#125;&#125; &lt;span v-if=\"time\"&gt;&#123;&#123;time&#125;&#125;&lt;/span&gt; &lt;slot name=\"start\"&gt;&lt;/slot&gt; &lt;div class=\"message-name\" v-if=\"name\" @click=\"onNameClick\"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class=\"message-text\" @click=\"onTextClick\"&gt; //不具名slot &lt;slot&gt;&#123;&#123;text&#125;&#125;&lt;/slot&gt; &lt;div class=\"message-date\" v-if=\"date\"&gt;&#123;&#123;date&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"message-avatar\" v-if=\"avatar\" :style=\"&#123;'background-image': 'url(' + avatar + ')'&#125;\" @click=\"onAvatarClick\"&gt;&lt;/div&gt; &lt;div class=\"message-label\" v-if=\"label\"&gt;&#123;&#123;label&#125;&#125;&lt;/div&gt; &lt;slot name=\"end\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 2. f7-messagebar要使用f7-messagebar需要在组件的f7-page加上no-toolbar和toolbar-fixed，使用no-toolbar会隐藏掉所有的.toolbar，而f7-message渲染后根标签是带有.toolbar，因此需要对f7-toolbar的样式进行修改，如下： 123456&lt;style lang=\"less\" scoped&gt;.toolbar.messagebar&#123; transform: none; transition: 0ms;&#125;&lt;/style&gt; 此外，f7-message中的textarea要进行数据双向绑定，直接在组件中使用v-model即可，代码如下： 123456789&lt;f7-messagebar placeholder=\"Message\" send-link=\"Send\" @submit=\"onSubmit\" v-model=\"messageText\"&gt; &lt;f7-link slot=\"before-textarea\" class=\"icon-only\"&gt; &lt;f7-icon icon=\"icon icon-camera\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt;&lt;/f7-messagebar&gt; 3. f7-picker-modal内嵌toolbar 2017.7.24 更新修改，不能使用navbar，会出现位置错乱，改为toolbar。此外，popup需放在app.vue中，不能放在页面组件中，否则navbar也会出现位置错乱 跟写一个页面的结构一样，在f7-picker-modal内部直接加入即可，在f7-picker-modal中的toolbar属于相对定位，所以不需要在f7-picker-modal中加上toolbar-through 4. $router跳转到首页的方法$router默认是使用ajax加载页面的，.vue页面中的html结构并不完整，framework7-vue是通过解析.vue中的内容，然后将内容插入到对应的位置，并实现过渡动画。因此，如果在router.js中加上app.vue的路由，那就是将app.vue的结构再嵌进f7-pages中，是无法正常显示的。目前我没有找到官方的方法来直接跳转到首页，因此是将app.vue中f7-pages里面的部分提取出来作为一个组件（结构跟其他.vue页面的结构一样，所以可以加上路由进行跳转），比如叫做mainPage.vue在app.vue中引入该组件，放到f7-pages里面，之后要跳转到首页就跟跳转到其他页面一样，将链接指向mainPage.vue的路由即可 2017.7.25 更新通过给主页面的f7-page加上name=&quot;main&quot;，在路由中使用this.$router.load({pageName: &#39;main&#39;})即可跳转到首页，无需将首页内容单独抽出作为一个组件 5. tabbar的实现在framework7官网中，根据f7+vue的官方文档的Navigation / Router页面，实现tabbar功能，如下： 123456789101112131415161718192021222324252627282930&lt;f7-toolbar tabbar&gt; &lt;f7-link route-tab-link=\"#tab1\" icon-f7=\"help\" href=\"/navbarsAndToolbars/tabbar/\" &gt;&lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab2\" icon-f7=\"drawers\" icon-badge=\"9\" badge-color=\"red\" href=\"/navbarsAndToolbars/tabbar/tab2/\" &gt;&lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab3\" icon-f7=\"cloud\" href=\"/navbarsAndToolbars/tabbar/tab3/\" &gt;&lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab4\" icon-f7=\"camera\" href=\"/navbarsAndToolbars/tabbar/tab4/\" &gt;&lt;/f7-link&gt;&lt;/f7-toolbar&gt;&lt;f7-tabs&gt; &lt;f7-tab route-tab-id=\"tab1\"&gt;&lt;/f7-tab&gt; &lt;f7-tab route-tab-id=\"tab2\"&gt;&lt;/f7-tab&gt; &lt;f7-tab route-tab-id=\"tab3\"&gt;&lt;/f7-tab&gt; &lt;f7-tab route-tab-id=\"tab4\"&gt;&lt;/f7-tab&gt;&lt;/f7-tabs&gt; 123456789101112131415161718192021222324//route.js&#123; path: '/navbarsAndToolbars/tabbar/', component: require('./pages/navbarsAndToolbars/tabbar.vue'), tabs: [ &#123; path: '/', tabId: 'tab1', component: require('./pages/navbarsAndToolbars/tab1.vue') &#125;, &#123; path: '/tab2/', tabId: 'tab2', component: require('./pages/navbarsAndToolbars/tab2.vue') &#125;, &#123; path: '/tab3/', tabId: 'tab3', component: require('./pages/navbarsAndToolbars/tab3.vue') &#125;, &#123; path: '/tab4/', tabId: 'tab4', component: require('./pages/navbarsAndToolbars/tab4.vue') &#125; ]&#125; 以上代码并不起作用，这段代码渲染后，在.page-content中渲染出来的f7-tab如下所示： 再查看framework7-vue中的tab.vue的源代码，发现tab标签是在渲染的时候通过比对$router中的tabId跟tab的id是否相同，若相同，则在f7-tab中渲染tabId对应的component 1234567891011121314151617181920212223//这里只取tab.vue中渲染的那段代码render: function (c) &#123; var self = this; const activeTab = self.routeInfo.activeTab; return c('div', &#123; staticClass: 'tab', attrs: &#123; id: self.id &#125;, class: &#123; 'active': (activeTab) ? activeTab.tabId === self.id : self.active &#125;, on: &#123; 'tab:show': self.onTabShow, 'tab:hide': self.onTabHide &#125; &#125;, //通过比对f7-tab标签的id和$router.tabId是否相同，相同则渲染对应的component [activeTab &amp;&amp; activeTab.tabId === self.id ? c(activeTab.component, &#123;tag: 'component', props: self.$route.params&#125;) : self.$slots.default] );&#125; 从上面的代码可以看出，f7-tab的内容时在页面跳转的时候进行渲染的，而通过tab-link进行tab页的切换只是修改f7-tab的类来显示对应的tab页，是无法显示其他tab页的内容的，需将tab-link改为route-tab-link，这样在tabbar中的a标签才会设置成active，而跳转则是通过href进行跳转，完整写法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//tabbar.vue&lt;template&gt; &lt;f7-page toolbar-fixed no-toolbar data-page=\"toolbar\"&gt; &lt;f7-navbar title=\"Tab Bar\" back-link=\"Back\" sliding&gt; &lt;f7-nav-right&gt; &lt;f7-link icon=\"icon icon-bars\" open-panel=\"left\"&gt;&lt;/f7-link&gt; &lt;/f7-nav-right&gt; &lt;/f7-navbar&gt; &lt;f7-toolbar tabbar&gt; &lt;f7-link route-tab-link=\"#tab1\" href=\"/navbarsAndToolbars/tabbar/\" active&gt; &lt;f7-icon f7=\"help\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"help_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab2\" href=\"/navbarsAndToolbars/tabbar/tab2/\"&gt; &lt;f7-icon f7=\"drawers\" class=\"inactive\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;f7-icon f7=\"drawers_fill\" class=\"active\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab3\" href=\"/navbarsAndToolbars/tabbar/tab3/\"&gt; &lt;f7-icon f7=\"cloud\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"cloud_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;f7-link route-tab-link=\"#tab4\" href=\"/navbarsAndToolbars/tabbar/tab4/\"&gt; &lt;f7-icon f7=\"camera\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"camera_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;/f7-link&gt; &lt;/f7-toolbar&gt; &lt;f7-tabs&gt; &lt;f7-tab id=\"tab1\"&gt;&lt;/f7-tab&gt; &lt;f7-tab id=\"tab2\"&gt;&lt;/f7-tab&gt; &lt;f7-tab id=\"tab3\"&gt;&lt;/f7-tab&gt; &lt;f7-tab id=\"tab4\"&gt;&lt;/f7-tab&gt; &lt;/f7-tabs&gt; &lt;/f7-page&gt;&lt;/template&gt;&lt;style lang=\"less\"&gt;.page[data-page=\"toolbar\"]&#123; .page-content&#123; padding-bottom: 44px; &#125; .toolbar&#123; transform: none; transition: 0ms; .active-state&#123; opacity: 1; transition: 0ms; &#125; a.active&#123; i.inactive&#123; display: none; &#125; i.active&#123; margin-left: 0; color: #007aff; &#125; &#125; &#125; .tabbar&#123; a:not(.active)&#123; i.active&#123; display: none; &#125; &#125; &#125;&#125;&lt;/style&gt;//tab1.vue&lt;template&gt; &lt;p&gt;tab1&lt;/p&gt;&lt;/template&gt;//tab2.vue&lt;template&gt; &lt;p&gt;tab2&lt;/p&gt;&lt;/template&gt;//tab3.vue&lt;template&gt; &lt;p&gt;tab3&lt;/p&gt;&lt;/template&gt;//tab4.vue&lt;template&gt; &lt;p&gt;tab4&lt;/p&gt;&lt;/template&gt; 123456789101112131415161718192021222324//route.js&#123; path: '/navbarsAndToolbars/tabbar/', component: require('./pages/navbarsAndToolbars/tabbar.vue'), tabs: [ &#123; path: '/', tabId: 'tab1', component: require('./pages/navbarsAndToolbars/tab1.vue') &#125;, &#123; path: '/tab2/', tabId: 'tab2', component: require('./pages/navbarsAndToolbars/tab2.vue') &#125;, &#123; path: '/tab3/', tabId: 'tab3', component: require('./pages/navbarsAndToolbars/tab3.vue') &#125;, &#123; path: '/tab4/', tabId: 'tab4', component: require('./pages/navbarsAndToolbars/tab4.vue') &#125; ]&#125; 其实不用tab的层级路由，直接在tabbar.vue中引入Vue组件并将其放到对应的f7-tab的方式要方便多了 以上这种通过tab层级路由实现tabbar的方式，由于是在一个页面中，并且只有一个.page-content，所以当tab页滚动后，再切换到其他tab页时，此时的tab页的位置处于上一个tab页滚动后的位置。若要实现不同tab页滚动位置不同，可以将.page-content作为tab页，并使用多个.page-content，可查看相关文档：page中的 “Page Content as Tabs” 部分。记住，这时不能使用层级路由，就按照官方文档最初始的写法，代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;f7-page no-toolbar toolbar-fixed tabs no-page-content data-page=\"toolbar\"&gt; &lt;f7-navbar title=\"Diff Scroll Tab Bar\" back-link=\"Back\" sliding&gt; &lt;f7-nav-right&gt; &lt;f7-link icon=\"icon icon-bars\" open-panel=\"left\"&gt;&lt;/f7-link&gt; &lt;/f7-nav-right&gt; &lt;/f7-navbar&gt; &lt;f7-toolbar tabbar labels&gt; &lt;f7-link tab-link=\"#tab1\" no-link-class active&gt; &lt;f7-icon f7=\"help\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"help_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Information&lt;/span&gt; &lt;/f7-link&gt; &lt;f7-link tab-link=\"#tab2\" no-link-class&gt; &lt;f7-icon f7=\"drawers\" class=\"inactive\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;f7-icon f7=\"drawers_fill\" class=\"active\"&gt; &lt;f7-badge color=\"red\"&gt;9&lt;/f7-badge&gt; &lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Inbox&lt;/span&gt; &lt;/f7-link&gt; &lt;f7-link tab-link=\"#tab3\" no-link-class&gt; &lt;f7-icon f7=\"cloud\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"cloud_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Upload&lt;/span&gt; &lt;/f7-link&gt; &lt;f7-link tab-link=\"#tab4\" no-link-class&gt; &lt;f7-icon f7=\"camera\" class=\"inactive\"&gt;&lt;/f7-icon&gt; &lt;f7-icon f7=\"camera_fill\" class=\"active\"&gt;&lt;/f7-icon&gt; &lt;span class=\"tabbar-label\"&gt;Photos&lt;/span&gt; &lt;/f7-link&gt; &lt;/f7-toolbar&gt; &lt;f7-page-content tab active id=\"tab1\"&gt;&lt;tab1&gt;&lt;/tab1&gt;&lt;/f7-page-content&gt; &lt;f7-page-content tab id=\"tab2\"&gt;&lt;tab2&gt;&lt;/tab2&gt;&lt;/f7-page-content&gt; &lt;f7-page-content tab id=\"tab3\"&gt;&lt;tab3&gt;&lt;/tab3&gt;&lt;/f7-page-content&gt; &lt;f7-page-content tab id=\"tab4\"&gt;&lt;tab4&gt;&lt;/tab4&gt;&lt;/f7-page-content&gt; &lt;/f7-page&gt;&lt;/template&gt; 12345678910&lt;script&gt;import Tab1 from './tab1'import Tab2 from './tab2'import Tab3 from './tab3'import Tab4 from './tab4'export default &#123; components: &#123; Tab1, Tab2, Tab3, Tab4 &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132&lt;style lang=\"less\"&gt;.page[data-page=\"toolbar\"]&#123; .page-content&#123; padding-bottom: 44px; &#125; .toolbar&#123; transform: none; transition: 0ms; .active-state&#123; opacity: 1; transition: 0ms; &#125; a.active&#123; i.inactive&#123; display: none; &#125; i.active&#123; margin-left: 0; color: #007aff; &#125; &#125; &#125; .tabbar&#123; a:not(.active)&#123; i.active&#123; display: none; &#125; &#125; &#125;&#125;&lt;/style&gt; framework7踩坑记（二）就更到这，后面继续更新基于framework7-vue实现的官方实例 vue-framework7，持续更新中，欢迎star","categories":[{"name":"webapp","slug":"webapp","permalink":"http://blog.ywulin.com/categories/webapp/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.ywulin.com/tags/vue/"},{"name":"framework7","slug":"framework7","permalink":"http://blog.ywulin.com/tags/framework7/"}]},{"title":"Framework7+Framework7-vue+vue踩坑记（一）","slug":"201707141526","date":"2017-07-14T07:27:13.000Z","updated":"2018-04-06T09:00:27.654Z","comments":true,"path":"201707141526.html","link":"","permalink":"http://blog.ywulin.com/201707141526.html","excerpt":"网上关于framework7-vue的博客基本没有，所以我决定用它来重构官网的Demo，来踩波坑，以下是我在使用framework7-vue时遇到的一些需要注意的点","text":"网上关于framework7-vue的博客基本没有，所以我决定用它来重构官网的Demo，来踩波坑，以下是我在使用framework7-vue时遇到的一些需要注意的点 1. this指向在定时器和framework7的api回调函数中，this会被修改指向其他作用域，在定时器或回调api调用之前定义一个变量保存指向vue作用域的this 2. Autocomplete功能实现framework7-vue没有Autocomplete组件，需要自己手动实现，Autocomplete主要通过js进行配置和初始化，自定义选项较多。Autocomplete需要使用到f7-list组件作为输入的容器，代码如下： 123456&lt;f7-list form&gt; &lt;f7-list-item&gt; &lt;f7-label&gt;Fruit&lt;/f7-label&gt; &lt;f7-input type=\"text\" placeholder=\"Fruit\" id=\"autocomplete-dropdown\"&gt;&lt;/f7-input&gt; &lt;/f7-list-item&gt;&lt;/f7-list&gt; 此外还需要在vue的生命周期mounted中进行初始化tips：不能在created中进行初始化，这时候模板尚未编译挂载，无法将插件绑定到dom上 1234567891011121314151617181920212223242526data() &#123; return &#123; fruits: ('Apple Apricot Avocado Banana Melon Orange Peach Pear Pineapple').split(' ') &#125;&#125;mounted() &#123; //注意，这里在插件初始化中this并非指向Vue实例的 let fruits = this.fruits; let autocompleteDropdownSimple = window.f7.autocomplete(&#123; input: '#autocomplete-dropdown', openIn: 'dropdown', source: function (autocomplete, query, render) &#123; let results = [] if (query.length === 0) &#123; render(results) return &#125; for (let i = 0; i &lt; fruits.length; i++) &#123; if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) &gt;= 0) &#123; results.push(fruits[i]) &#125; &#125; render(results) &#125; &#125;)&#125; 其他类型的选项请参照官网原生文档实现：http://docs.framework7.cn/Index/autocomplete.html 3. this.$$ &amp; this.Dom7 中无jsonp请求在this.$$中无jsonp请求，若要使用jsonp，可安装vue-resource（不过该插件作者已宣布不再更新），用法一样 4. Calendar / Datepickerframework7-vue没有Calendar / Datepicker的组件，需要手动实现，跟Autocomplete一样，代码如下 123456789&lt;template&gt; &lt;f7-page&gt; &lt;f7-list form&gt; &lt;f7-list-item&gt; &lt;f7-input type=\"text\" placeholder=\"Select date\" readonly id=\"calendar-disabled\"&gt;&lt;/f7-input&gt; &lt;/f7-list-item&gt; &lt;/f7-list&gt; &lt;/f7-page&gt;&lt;/template&gt; 123456789&lt;script&gt;export default&#123; mounted () &#123; let calendarDefault = this.$f7.calendar(&#123; input: '#calendar-default' &#125;) &#125;&#125;&lt;/script&gt; 5. Contactsframework7-vue中有contacts-list组件，其.list.group-title在谷歌浏览器调试时，position: sticky中top是相对于viewport定位的，所以滚动后处于浏览器顶部，被navbar遮住，但在手机上是正常显示的，其top是相对于.page-content定位的 6. 层级路由framework7-vue在本文章撰写时除了在同页面Tab中有层级路由外，没有实现页面间的层级路由，跟vue-router不一样，要实现页面间的层级跳转，路由的写法跟平时写法一致，直接跳转即可，如下 123456789101112131415[ &#123; path: '/floatingAction/', component: require('./pages/floatingAction/floatingAction.vue'), &#125;, &#123; //我这里为了显示出层级关系，将其上一级页面的路由也包含进去，事实上是可以不用这么做的 path: '/floatingAction/staticFloating/', component: require('./pages/floatingAction/staticFloating.vue') &#125;, &#123; path: '/floatingAction/speedDial/', component: require('./pages/floatingAction/speedDial.vue') &#125;] 7. f7-input: type=”select”f7-input中设置type=&quot;select&quot;，不会有默认选中项，需要在f7-input中绑定v-model=&quot;selected&quot;，而给option设置selected属性是不会显示选中项的 8. 无限滚动Infinite Scroll无限滚动的实现是在f7-page中加上infinite-scroll，滚动事件为@infinite=&quot;doSomething&quot;，页面每次变更都需要重新刷新一次浏览器，否则infinite事件不会绑定，infinite-scroll是在page:init即页面初始化时初始化的，而热加载不会重新执行一遍page:init。以下是代码实现： 12345678910111213&lt;template&gt; &lt;f7-page infinite-scroll @infinite=\"onInfiniteScroll\"&gt; &lt;f7-navbar title=\"Infinite Scroll\" back-link=\"返回\" sliding&gt; &lt;f7-nav-right&gt; &lt;f7-link icon=\"icon icon-bars\" open-panel=\"left\"&gt;&lt;/f7-link&gt; &lt;/f7-nav-right&gt; &lt;/f7-navbar&gt; &lt;f7-block-title&gt;SCROLL BOTTOM&lt;/f7-block-title&gt; &lt;f7-list&gt; &lt;f7-list-item v-for=\"item in items\" :title=\"'Item ' + item\"&gt;&lt;/f7-list-item&gt; &lt;/f7-list&gt; &lt;/f7-page&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334&lt;script&gt;export default &#123; data () &#123; return &#123; items: 20, loading: false, maxLength: 60 &#125; &#125;, methods: &#123; onInfiniteScroll: function () &#123; if (this.loading) &#123; return; &#125; this.loading = true; let _this = this; setTimeout(function () &#123; _this.loading = false; if (_this.items &gt;= _this.maxLength) &#123; _this.$f7.detachInfiniteScroll(_this.$$('.infinite-scroll')) _this.$$('.infinite-scroll-preloader').remove() return &#125; _this.items += 20; &#125;, 1000) &#125; &#125;&#125;&lt;/script&gt; 9. f7-list的灵活性f7-list的比较灵活，严格来说应该是f7-list-item比较灵活，自由度高，该组件在设计时添加了不少slot选项来分发内容 灵活运用slots可以实现各种列表效果，如以下效果： 代码的实现如下： 1234567891011121314151617181920212223242526&lt;f7-list-item title=\"No icons here\"&gt; &lt;ul slot=\"root\"&gt; &lt;f7-list-item link=\"#\" media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"Ivan Petrov\" after=\"CEO\" &gt;&lt;/f7-list-item&gt; &lt;f7-list-item link=\"#\" media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"Two icons here\" &gt;&lt;/f7-list-item&gt; &lt;f7-list-item title=\"No icons here\"&gt;&lt;/f7-list-item&gt; &lt;f7-list-item link=\"#\" media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"Ultra long text goes here, no, it is really really long\" &gt;&lt;/f7-list-item&gt; &lt;f7-list-item media=\"&lt;i class='icon icon-f7'&gt;&lt;/i&gt;\" title=\"With switch\"&gt; &lt;f7-input type='switch' slot=\"after\"&gt;&lt;/f7-input&gt; &lt;/f7-list-item&gt; &lt;/ul&gt;&lt;/f7-list-item&gt; 10. $router要在javascript中使用路由$router，用法为this.$router，$router是保存在vue作用域中的 framework7-vue的注意点目前就写到这，后面继续更新基于framework7-vue实现的官方实例 vue-framework7，持续更新中，欢迎star","categories":[{"name":"webapp","slug":"webapp","permalink":"http://blog.ywulin.com/categories/webapp/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.ywulin.com/tags/vue/"},{"name":"framework7","slug":"framework7","permalink":"http://blog.ywulin.com/tags/framework7/"}]},{"title":"gulp自动化构建工具学习","slug":"201706251602","date":"2017-06-25T08:02:45.000Z","updated":"2018-04-06T08:59:21.245Z","comments":true,"path":"201706251602.html","link":"","permalink":"http://blog.ywulin.com/201706251602.html","excerpt":"Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。在这里介绍了gulp的入门，插件和gulpfile.js配置文件。","text":"Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。在这里介绍了gulp的入门，插件和gulpfile.js配置文件。 入门 全局安装gulp $ npm install -g gulp 新建一个文件夹作为项目，进入该文件夹，初始化 $ mkdir example $ npm init 安装开发依赖（devDependences） $ npm install --save-dev gulp 在项目根目录新建 gulpfile.js 文件 $ touch gulpfile.js 编辑gulpfile.js文件 12345var gulp = require('gulp'); gulp.task('default', function () &#123; //默认任务代码 &#125;); 命令行运行gulp，即可运行默认任务 $ gulp api介绍 这里只列出api常用用法，了解更多请查阅官网http://www.gulpjs.com.cn/docs/api/ gulp.src(globs[, options]) 输出符合匹配的文件并返回一个stream，可pipe到其他插件 golbs(类型：String或Array) String: ‘src/js/*.js’Array: [‘src/js/*.js’, ‘src/css/*.css’] gulp.dest(path[, options]) 将pipe进来的数据转存为指定文件夹下的文件，若指定文件夹不存在，则自动创建该文件夹 path(类型：String或Function) String: ‘dist/js’Function: 在函数中返回相应路径 gulp.task(name[, deps], fn) 定义一个任务 123gulp.task('something', functio () &#123; doSomething();&#125;); name(类型：String) 任务的名字，可在命令行中通过name运行任务，$ gulp name deps(类型：Array) 一个包含任务列表的数组，这些任务会在当前任务运行之前完成 fn(类型：Function) 该任务要执行的内容 gulp.watch(glob[, opts], tasks) 或 gulp.watch(globs[, opts, cb]) 文件监视，当指定匹配文件发生变化时，执行tasks或函数cb glob(类型：String或Array) tasks(类型：String或Array) 文件变动后执行之前定义好的任务 cb(类型： Function) 传入一个记录文件变动的event对象，event.type记录变动类型：added, changed, deleted；event.path记录变动文件的路径 gulp插件介绍 gulp-less/gulp-sass 预编译less/sass文件为css文件 安装：$ npm install --save-dev gulp-less gulp-autoprefixer 设置浏览器版本，css文件自动添加浏览器前缀 安装：$ npm install --save-dev gulp-autoprefixer gulp-minify-css 压缩css文件 安装：$ npm install --save-dev gulp-minify-css gulp-rename 重命名要输出的文件，如将.css重命名为.min.css 安装：$ npm install --save-dev gulp-rename vinyl-buffer 将vinyl对象内容中的stream转换为buffer 安装：$ npm install --save-dev vinyl-buffer vinyl-source-stream 将Browserify的bundle()的输出转换为Gulp可用的vinyl流 安装：$ npm install --save-dev vinyl-source-stream gulp-sourcemaps 编写内联sourcemaps 安装：$ npm install --save-dev gulp-sourcemaps browserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，在这里用来管理依赖 安装：$ npm install --save-dev browserify babelify 将ES6转换成ES5 安装：$ npm install --save-dev babelify gulp-uglify 压缩 JavaScript 文件 安装：$ npm install --save-dev gulp-uglify gulp-imagemin 压缩 png，jpeg，gif和svg图片资源 安装：$ npm install --save-dev gulp-imagemin gulp-cache 图片缓存，只有图片替换了才压缩 安装：$ npm install --save-dev gulp-cache gulp-clean 移除文件或文件夹 安装：$ npm install --save-dev gulp-clean gulp-util 包含gulp的一些实用功能，在这里用来打印编译错误 安装：$ npm install --save-dev gulp-util gulp-notify 当文件变更时提醒 安装：$ npm install gulp-notify gulp-connect gulp中用来运行服务器的插件，内含LiveReload，自动刷新浏览器 安装：$ npm install --save-dev gulp-connect gulpfile.js文件配置 内含 ES6 转 ES5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var gulp = require('gulp'), less = require('gulp-less'), autoprefixer = require('gulp-autoprefixer'), minifycss = require('gulp-minify-css'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), rename = require('gulp-rename'), clean = require('gulp-clean'), cache = require('gulp-cache'), notify = require('gulp-notify'), browserify = require('browserify'), babelify = require('babelify'), buffer = require('vinyl-buffer'), source = require('vinyl-source-stream'), sourcemaps = require('gulp-sourcemaps'), gutil = require('gulp-util'), connect = require('gulp-connect');/* * styles任务，将'src/less'目录下的less文件转换成css文件， * 并加上浏览器前缀，存放于'dist/css'目录下，之后重命名加上.min，压缩， * 保存为.min.css文件，之后刷新浏览器，并提醒style任务完成 */gulp.task('styles', function() &#123; return gulp.src('src/less/*.less') .pipe(less()) .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4')) .on('error', gutil.log) .pipe(gulp.dest('dist/css')) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('dist/css')) .pipe(connect.reload()) .pipe(notify(&#123;message: 'style task complete'&#125;);&#125;);/* * scripts任务，通过browserify设置入口文件，然后用babelify将 * es6转换成es5，保存在'dist/js'目录下，之后压缩js文件，重命名 * 保存为.min.js文件 */gulp.task('scripts', function() &#123; var b = browserify(&#123; entries: 'src/js/cart.js', debug: true &#125;); return b.transform(babelify.configure(&#123; presets: [\"es2015\"] &#125;)) .bundle() .on('error', gutil.log) .pipe(source('cart.js')) .pipe(gulp.dest('dist/js')) .pipe(buffer()) .pipe(sourcemaps.init(&#123;loadMaps: true&#125;)) .pipe(uglify()) .on('error', gutil.log) .pipe(sourcemaps.write('./')) .pipe(rename(&#123; suffix: '.min'&#125;)) .pipe(gulp.dest('dist/js')) .pipe(connect.reload());&#125;);/* * images任务，读取'src/img'目录下的图片，压缩并保存到'dist/img'目录下 */gulp.task('images', function() &#123; return gulp.src('src/img/*') .pipe(cache(imagemin([ imagemin.gifsicle(&#123;interlaced: true&#125;), imagemin.jpegtran(&#123;progressive: true&#125;), imagemin.optipng(&#123;optimizationLevel: 5&#125;), imagemin.svgo(&#123;plugins: [&#123;removeViewBox: true&#125;]&#125;)]))) .on('error', gutil.log) .pipe(gulp.dest('dist/img')) .pipe(connect.reload());&#125;);/* * html任务，读取'src'目录下的html文件，并保存到'dist'目录下 */gulp.task('html', function() &#123; return gulp.src('src/shangcheng/*.html') .pipe(gulp.dest('dist/')) .pipe(connect.reload());&#125;);/* * connect任务，运行服务器并自动刷新浏览器 */gulp.task('connect', function() &#123; connect.server(&#123; livereload: true &#125;);&#125;);/* * clean任务，将dist目录下的css文件，js文件，图片文件和html文件清除 */gulp.task('clean', function() &#123; return gulp.src(['dist/css', 'dist/js', 'dist/img', 'dist/*.html'], &#123;read: false&#125;) .pipe(clean());&#125;);/* * 默认任务，在开始执行styles任务，scripts任务，images任务，html任务 * 之前先执行clean任务 */gulp.task('default', ['clean'], function() &#123; gulp.start('styles', 'scripts', 'images', 'html');&#125;);/* * 监视任务，监听less文件，js文件，图片文件和html文件的变更 */gulp.task('watch', function() &#123; //监听所有.less gulp.watch('src/less/*.less', ['styles']); //监听所有.js文件 gulp.watch('src/js/*.js', ['scripts']); //监听所有图片文件 gulp.watch('src/img/*', ['images']); //监听html文件 gulp.watch('src/*.html', ['html']);&#125;);/* * server任务，执行connect任务和watch任务 */gulp.task('server', ['connect', 'watch']); 不含 ES6 的 js 文件任务 1234567891011gulp.task('scripts', function() &#123; return gulp.src('src/js/*.js') .pipe(gulp.dest('dist/js')) .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(sourcemaps.init(&#123;loadMaps: true&#125;)) .pipe(uglify()) .pipe(sourcemaps.write('./')) .on('error', gutil.log) .pipe(gulp.dest('dist/js')) .pipe(connect.reload());&#125;);","categories":[{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://blog.ywulin.com/categories/自动化构建工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://blog.ywulin.com/tags/gulp/"}]}]}